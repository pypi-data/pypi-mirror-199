
 

// This file is autogenerated. DO NOT EDIT

#pragma once
#include <robotpy_build.h>


#include <..\src\include\frc2\command\SelectCommand.h>

#include <frc2/command/Command.h>
#include <frc2/command/Subsystem.h>
#include <src/SelectCommandKey.h>



#include <rpygen/frc2__CommandBase.hpp>

namespace rpygen {

using namespace frc2;


template <typename CfgBase>
using PyTrampolineCfgBase_frc2__SelectCommand =
    PyTrampolineCfg_frc2__CommandBase<
CfgBase
>;

template <typename Key, typename CfgBase = EmptyTrampolineCfg>
struct PyTrampolineCfg_frc2__SelectCommand :
    PyTrampolineCfgBase_frc2__SelectCommand< CfgBase>
{
    using Base = frc2::SelectCommand<Key>;

    using override_base_Initialize_v = frc2::SelectCommand<Key>;
    using override_base_Execute_v = frc2::SelectCommand<Key>;
    using override_base_End_b = frc2::SelectCommand<Key>;
    using override_base_IsFinished_v = frc2::SelectCommand<Key>;
    using override_base_KRunsWhenDisabled_v = frc2::SelectCommand<Key>;
    using override_base_KGetInterruptionBehavior_v = frc2::SelectCommand<Key>;
    using override_base_InitSendable_RTSendableBuilder = frc2::SelectCommand<Key>;
};


template <typename PyTrampolineBase, typename PyTrampolineCfg>
using PyTrampolineBase_frc2__SelectCommand =
    PyTrampoline_frc2__CommandBase<
        PyTrampolineBase
        
        , PyTrampolineCfg
    >
;

template <typename PyTrampolineBase, typename Key, typename PyTrampolineCfg>
struct PyTrampoline_frc2__SelectCommand : PyTrampolineBase_frc2__SelectCommand<PyTrampolineBase, PyTrampolineCfg> {
    using PyTrampolineBase_frc2__SelectCommand<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_frc2__SelectCommand;



#ifndef RPYGEN_DISABLE_Initialize_v
    void Initialize() override {
        using LookupBase = typename PyTrampolineCfg::Base;
        using CxxCallBase = typename PyTrampolineCfg::override_base_Initialize_v;
        PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(void), LookupBase,
            "initialize", );
        return CxxCallBase::Initialize();
    }
#endif

#ifndef RPYGEN_DISABLE_Execute_v
    void Execute() override {
        using LookupBase = typename PyTrampolineCfg::Base;
        using CxxCallBase = typename PyTrampolineCfg::override_base_Execute_v;
        PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(void), LookupBase,
            "execute", );
        return CxxCallBase::Execute();
    }
#endif

#ifndef RPYGEN_DISABLE_End_b
    void End(bool interrupted) override {
        using LookupBase = typename PyTrampolineCfg::Base;
        using CxxCallBase = typename PyTrampolineCfg::override_base_End_b;
        PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(void), LookupBase,
            "end", interrupted);
        return CxxCallBase::End(std::move(interrupted));
    }
#endif

#ifndef RPYGEN_DISABLE_IsFinished_v
    bool IsFinished() override {
        using LookupBase = typename PyTrampolineCfg::Base;
        using CxxCallBase = typename PyTrampolineCfg::override_base_IsFinished_v;
        PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(bool), LookupBase,
            "isFinished", );
        return CxxCallBase::IsFinished();
    }
#endif

#ifndef RPYGEN_DISABLE_KRunsWhenDisabled_v
    bool RunsWhenDisabled() const override {
        using LookupBase = typename PyTrampolineCfg::Base;
        using CxxCallBase = typename PyTrampolineCfg::override_base_KRunsWhenDisabled_v;
        PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(bool), LookupBase,
            "runsWhenDisabled", );
        return CxxCallBase::RunsWhenDisabled();
    }
#endif

#ifndef RPYGEN_DISABLE_KGetInterruptionBehavior_v
    Command::InterruptionBehavior GetInterruptionBehavior() const override {
        using LookupBase = typename PyTrampolineCfg::Base;
        using CxxCallBase = typename PyTrampolineCfg::override_base_KGetInterruptionBehavior_v;
        PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(Command::InterruptionBehavior), LookupBase,
            "getInterruptionBehavior", );
        return CxxCallBase::GetInterruptionBehavior();
    }
#endif

#ifndef RPYGEN_DISABLE_InitSendable_RTSendableBuilder
    void InitSendable(wpi::SendableBuilder& builder) override {
        auto custom_fn = [&](py::function fn) {
  auto builderHandle = py::cast(builder, py::return_value_policy::reference);
  fn(builderHandle);
}
;
        using LookupBase = typename PyTrampolineCfg::Base;
        using CxxCallBase = typename PyTrampolineCfg::override_base_InitSendable_RTSendableBuilder;
        RPYBUILD_OVERRIDE_CUSTOM_IMPL(PYBIND11_TYPE(void), LookupBase,
            "initSendable", InitSendable, builder);
        return CxxCallBase::InitSendable(std::forward<decltype(builder)>(builder));
    }
#endif




};

}; // namespace rpygen


namespace rpygen {

using namespace frc2;


template <typename Key>
struct bind_frc2__SelectCommand {

    
    
    
      using SelectCommand_Trampoline = rpygen::PyTrampoline_frc2__SelectCommand<typename frc2::SelectCommand<Key>, Key, typename rpygen::PyTrampolineCfg_frc2__SelectCommand<Key>>;
    static_assert(std::is_abstract<SelectCommand_Trampoline>::value == false, "frc2::SelectCommand<Key> " RPYBUILD_BAD_TRAMPOLINE);
py::class_<typename frc2::SelectCommand<Key>, SelectCommand_Trampoline, frc2::CommandBase> cls_SelectCommand;




    py::module &m;
    std::string clsName;

bind_frc2__SelectCommand(py::module &m, const char * clsName) :
    cls_SelectCommand(m, clsName),



    m(m),
    clsName(clsName)
{
    
}

void finish(const char * set_doc = NULL, const char * add_doc = NULL) {

    
  cls_SelectCommand.doc() =
    "A command composition that runs one of a selection of commands, either using\n"
"a selector and a key to command mapping, or a supplier that returns the\n"
"command directly at runtime.\n"
"\n"
"The rules for command compositions apply: command instances that are\n"
"passed to it are owned by the composition and cannot be added to any other\n"
"composition or scheduled individually, and the composition requires all\n"
"subsystems its components require.";

  cls_SelectCommand
      .def(py::init<std::function<Key ( )>, std::vector<std::pair<Key, std::shared_ptr<Command> > >&&>(),
      py::arg("selector").none(false), py::arg("commands"), release_gil()
  )
    
      .def(py::init<std::function<std::shared_ptr<Command> ( )>>(),
      py::arg("toRun").none(false), release_gil(), py::doc(
    "Creates a new selectcommand.\n"
"\n"
":deprecated: Replace with {@link ProxyCommand},\n"
"             composing multiple of them in a {@link ParallelRaceGroup} if needed.\n"
"\n"
":param toRun: a supplier providing the command to run")
  )
    
      .def("initialize", &frc2::SelectCommand<Key>::Initialize, release_gil()
  )
    
      .def("execute", &frc2::SelectCommand<Key>::Execute, release_gil()
  )
    
      .def("end", &frc2::SelectCommand<Key>::End,
      py::arg("interrupted"), release_gil()
  )
    
      .def("isFinished", &frc2::SelectCommand<Key>::IsFinished, release_gil()
  )
    
      .def("runsWhenDisabled", &frc2::SelectCommand<Key>::RunsWhenDisabled, release_gil()
  )
    
      .def("getInterruptionBehavior", &frc2::SelectCommand<Key>::GetInterruptionBehavior, release_gil()
  )
    
      .def("initSendable", &frc2::SelectCommand<Key>::InitSendable,
      py::arg("builder"), release_gil()
  )
    
;

  

    if (set_doc) {
        cls_SelectCommand.doc() = set_doc;
    }
    if (add_doc) {
        cls_SelectCommand.doc() = py::cast<std::string>(cls_SelectCommand.doc()) + add_doc;
    }

    
}

}; // struct bind_frc2__SelectCommand

}; // namespace rpygen