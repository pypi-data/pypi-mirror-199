{
  "ADDITIONAL_OPTIONS": {
    "bool_opt": {
      "desc": "A boolean option",
      "value": true,
      "type": "bool"
    },
    "int_opt": {
      "desc": "An integer option",
      "value": 42,
      "type": "int",
      "order": -1
    },
    "float_opt": {
      "desc": "A float option",
      "value": 3.14,
      "type": "float"
    },
    "string_opt": {
      "desc": "A string option",
      "value": "Hello World",
      "type": "string"
    },
    "list_opt": {
      "desc": "A list option",
      "value": [
        "Hello",
        "World"
      ],
      "type": "list"
    },
    "text_opt": {
      "desc": "A text option",
      "value": "Hello\nWorld",
      "type": "text"
    },
    "json_opt": {
      "desc": "A json option",
      "value": {
        "a": 1,
        "b": 2
      },
      "type": "json"
    },
    "auto_opt": {
      "desc": "An auto option",
      "value": {},
      "type": "auto"
    },
    "ns_opt": {
      "desc": "A namespace option",
      "type": "namespace",
      "value": {
        "nest_opt": {
          "desc": "A nested ns option",
          "type": "namespace",
          "value": {
            "x": {
              "desc": "An option of a nested ns option",
              "value": 1,
              "itype": "int",
              "type": "choice",
              "choices": [
                1,
                2,
                3
              ],
              "choices_desc": [
                "One",
                "Two",
                "Three"
              ]
            }
          }
        },
        "y": {
          "desc": "Another option of a ns option",
          "order": -1,
          "value": [
            1,
            2,
            3
          ],
          "itype": "float",
          "type": "mchoices",
          "choices": [
            1,
            2,
            3,
            4,
            5
          ],
          "choices_desc": [
            "One",
            "Two",
            "Three",
            "Four",
            "Five"
          ]
        }
      }
    }
  },
  "RUNNING_OPTIONS": {
    "Local": {
      "desc": "The options for running the pipeline locally",
      "command": "python -m pipeline @${configfile} --datadir ${datadir}",
      "value": {
        "configfile": {
          "desc": "The configuration file for the pipeline, typically generated by this wizard\n",
          "required": true,
          "value": "config.toml",
          "placeholder": "config.toml"
        },
        "datadir": {
          "desc": "The directory where the data is stored",
          "required": true,
          "value": ""
        }
      }
    }
  },
  "PIPELINE_OPTIONS": {
    "loglevel": {
      "type": "choice",
      "choices": [
        "debug",
        "info",
        "warning",
        "error",
        "critical"
      ],
      "value": "info",
      "hidden": true,
      "desc": "Logging level. This affects the log level of the main plugin."
    },
    "cache": {
      "type": "auto",
      "value": true,
      "hidden": true,
      "desc": "# Job caching\n\nIf cache set to False (detected in the sequence of configuration files,\nPipen constructor, and process definition), the job is running anyway\nregardless of previous runs.\n\nIf a previous run of a job fails, the job will be running anyway.\n\nIf a job is done successfully, a signature file will be generated for\nthe job. When we try to run the job again, the signature will be used\nto check if we can skip running the job again but to use the results\ngenerated by previous run.\n\nWe can also do a force-cache for a job by setting cache to \"force\".\nThis make sure of the results of previous successful run regardless of\ninput or script changes. This is useful for the cases that, for example,\nyou make some changes to input/script, but you don't want them to take\neffect immediately, especially when the job takes long time to run.\n"
    },
    "num_retries": {
      "type": "int",
      "value": 3,
      "hidden": true,
      "desc": "Number of retries when a job fails. "
    },
    "submission_batch": {
      "type": "int",
      "value": 8,
      "hidden": true,
      "desc": "Number of jobs to submit at a time"
    },
    "scheduler": {
      "value": "local",
      "hidden": true,
      "desc": "The scheduler to use"
    },
    "scheduler_opts": {
      "desc": "The scheduler options",
      "value": {
        "<option_name>": {
          "type": "auto",
          "desc": "The value of the option"
        }
      }
    },
    "plugin_opts": {
      "desc": "The plugin options of your pipeline",
      "value": {
        "<plugin_name>_<plugin_opt_name>": {
          "desc": "The value of plugin option `<plugin_name>_<plugin_opt_name>`",
          "type": "str"
        }
      }
    },
    "forks": {
      "type": "int",
      "value": 1,
      "desc": "Number of jobs to run in parallel for each process\n\nThe ability to run multiple jobs in parallel is provided by the the scheduler\nsystem. For example, if you use the local scheduler, the jobs will be run in\nparallel using the `multiprocessing` module. If you use the `sge` scheduler,\nthe jobs will be submitted to the slurm scheduler and run in parallel.\n"
    },
    "dirsig": {
      "type": "int",
      "value": 1,
      "hidden": true,
      "desc": "How deep we should go to check directory signature"
    },
    "error_strategy": {
      "type": "choice",
      "choices": [
        "ignore",
        "retry",
        "halk"
      ],
      "choices_desc": [
        "Ignore the error and continue to run next jobs",
        "Retry the job",
        "Halt the pipeline"
      ],
      "value": "ignore",
      "desc": "What to do when a job fails",
      "hidden": true
    },
    "name": {
      "type": "str",
      "value": "ExamplePipeline",
      "placeholder": "ExamplePipeline",
      "cached_file": "example-example-py-examplepipeline.json",
      "desc": "The name of the pipeline. It will affect the names of working directory and the result directory"
    },
    "desc": {
      "type": "str",
      "value": "An example pipeline showing how pipen-cli-config works.",
      "desc": "The description of the pipeline, shows in the log and report."
    },
    "outdir": {
      "desc": "The output directory of your pipeline",
      "placeholder": "./<name>_results",
      "type": "str",
      "value": ""
    }
  },
  "PROCESSES": {
    "P1": {
      "desc": "# Undescribed process.\n\n",
      "value": {
        "envs": {
          "desc": "Environment variables for the process, used across jobs",
          "value": {}
        },
        "plugin_opts": {
          "desc": "The plugin options of your pipeline",
          "value": {
            "<plugin_name>_<plugin_opt_name>": {
              "desc": "The value of plugin option `<plugin_name>_<plugin_opt_name>`",
              "type": "str",
              "value": [
                [
                  "",
                  ""
                ]
              ]
            }
          }
        },
        "scheduler_opts": {
          "desc": "The scheduler options",
          "value": {
            "<option_name>": {
              "type": "auto",
              "desc": "The value of the option",
              "value": [
                [
                  "",
                  ""
                ]
              ]
            }
          }
        },
        "forks": {
          "type": "int",
          "value": 1,
          "desc": "Number of jobs to run in parallel for each process\n\nThe ability to run multiple jobs in parallel is provided by the the scheduler\nsystem. For example, if you use the local scheduler, the jobs will be run in\nparallel using the `multiprocessing` module. If you use the `sge` scheduler,\nthe jobs will be submitted to the slurm scheduler and run in parallel.\n"
        },
        "cache": {
          "type": "auto",
          "value": true,
          "hidden": true,
          "desc": "# Job caching\n\nIf cache set to False (detected in the sequence of configuration files,\nPipen constructor, and process definition), the job is running anyway\nregardless of previous runs.\n\nIf a previous run of a job fails, the job will be running anyway.\n\nIf a job is done successfully, a signature file will be generated for\nthe job. When we try to run the job again, the signature will be used\nto check if we can skip running the job again but to use the results\ngenerated by previous run.\n\nWe can also do a force-cache for a job by setting cache to \"force\".\nThis make sure of the results of previous successful run regardless of\ninput or script changes. This is useful for the cases that, for example,\nyou make some changes to input/script, but you don't want them to take\neffect immediately, especially when the job takes long time to run.\n"
        },
        "scheduler": {
          "value": "local",
          "hidden": true,
          "desc": "The scheduler to use"
        },
        "dirsig": {
          "type": "int",
          "value": 1,
          "hidden": true,
          "desc": "How deep we should go to check directory signature"
        },
        "error_strategy": {
          "type": "choice",
          "choices": [
            "ignore",
            "retry",
            "halk"
          ],
          "choices_desc": [
            "Ignore the error and continue to run next jobs",
            "Retry the job",
            "Halt the pipeline"
          ],
          "value": "ignore",
          "desc": "What to do when a job fails",
          "hidden": true
        },
        "num_retries": {
          "type": "int",
          "value": 3,
          "hidden": true,
          "desc": "Number of retries when a job fails. "
        }
      }
    },
    "P4": {
      "desc": "# The P4 process\n\n",
      "value": {
        "envs": {
          "desc": "Environment variables for the process, used across jobs",
          "value": {
            "abc": {
              "atype": "str",
              "value": "123",
              "desc": "The abc env"
            },
            "method": {
              "action": "choice",
              "atype": "str",
              "type": "choice",
              "value": "a",
              "choices": [
                "a",
                "b",
                "c"
              ],
              "choices_desc": [
                "Use method a",
                "Use method b",
                "Use method c"
              ],
              "desc": "The method to use"
            }
          }
        },
        "plugin_opts": {
          "desc": "The plugin options of your pipeline",
          "value": {
            "<plugin_name>_<plugin_opt_name>": {
              "desc": "The value of plugin option `<plugin_name>_<plugin_opt_name>`",
              "type": "str",
              "value": [
                [
                  "",
                  ""
                ]
              ]
            }
          }
        },
        "scheduler_opts": {
          "desc": "The scheduler options",
          "value": {
            "<option_name>": {
              "type": "auto",
              "desc": "The value of the option",
              "value": [
                [
                  "",
                  ""
                ]
              ]
            }
          }
        },
        "forks": {
          "type": "int",
          "value": 1,
          "desc": "Number of jobs to run in parallel for each process\n\nThe ability to run multiple jobs in parallel is provided by the the scheduler\nsystem. For example, if you use the local scheduler, the jobs will be run in\nparallel using the `multiprocessing` module. If you use the `sge` scheduler,\nthe jobs will be submitted to the slurm scheduler and run in parallel.\n"
        },
        "cache": {
          "type": "auto",
          "value": true,
          "hidden": true,
          "desc": "# Job caching\n\nIf cache set to False (detected in the sequence of configuration files,\nPipen constructor, and process definition), the job is running anyway\nregardless of previous runs.\n\nIf a previous run of a job fails, the job will be running anyway.\n\nIf a job is done successfully, a signature file will be generated for\nthe job. When we try to run the job again, the signature will be used\nto check if we can skip running the job again but to use the results\ngenerated by previous run.\n\nWe can also do a force-cache for a job by setting cache to \"force\".\nThis make sure of the results of previous successful run regardless of\ninput or script changes. This is useful for the cases that, for example,\nyou make some changes to input/script, but you don't want them to take\neffect immediately, especially when the job takes long time to run.\n"
        },
        "scheduler": {
          "value": "local",
          "hidden": true,
          "desc": "The scheduler to use"
        },
        "dirsig": {
          "type": "int",
          "value": 1,
          "hidden": true,
          "desc": "How deep we should go to check directory signature"
        },
        "error_strategy": {
          "type": "choice",
          "choices": [
            "ignore",
            "retry",
            "halk"
          ],
          "choices_desc": [
            "Ignore the error and continue to run next jobs",
            "Retry the job",
            "Halt the pipeline"
          ],
          "value": "ignore",
          "desc": "What to do when a job fails",
          "hidden": true
        },
        "num_retries": {
          "type": "int",
          "value": 3,
          "hidden": true,
          "desc": "Number of retries when a job fails. "
        }
      }
    }
  },
  "PROCGROUPS": {
    "MyGroup": {
      "PROCESSES": {
        "P2": {
          "desc": "# Undescribed process.\n\n",
          "value": {
            "envs": {
              "desc": "Environment variables for the process, used across jobs",
              "value": {}
            },
            "plugin_opts": {
              "desc": "The plugin options of your pipeline",
              "value": {
                "<plugin_name>_<plugin_opt_name>": {
                  "desc": "The value of plugin option `<plugin_name>_<plugin_opt_name>`",
                  "type": "str"
                }
              }
            },
            "scheduler_opts": {
              "desc": "The scheduler options",
              "value": {
                "<option_name>": {
                  "type": "auto",
                  "desc": "The value of the option"
                }
              }
            },
            "forks": {
              "type": "int",
              "value": 1,
              "desc": "Number of jobs to run in parallel for each process\n\nThe ability to run multiple jobs in parallel is provided by the the scheduler\nsystem. For example, if you use the local scheduler, the jobs will be run in\nparallel using the `multiprocessing` module. If you use the `sge` scheduler,\nthe jobs will be submitted to the slurm scheduler and run in parallel.\n"
            },
            "cache": {
              "type": "auto",
              "value": true,
              "hidden": true,
              "desc": "# Job caching\n\nIf cache set to False (detected in the sequence of configuration files,\nPipen constructor, and process definition), the job is running anyway\nregardless of previous runs.\n\nIf a previous run of a job fails, the job will be running anyway.\n\nIf a job is done successfully, a signature file will be generated for\nthe job. When we try to run the job again, the signature will be used\nto check if we can skip running the job again but to use the results\ngenerated by previous run.\n\nWe can also do a force-cache for a job by setting cache to \"force\".\nThis make sure of the results of previous successful run regardless of\ninput or script changes. This is useful for the cases that, for example,\nyou make some changes to input/script, but you don't want them to take\neffect immediately, especially when the job takes long time to run.\n"
            },
            "scheduler": {
              "value": "local",
              "hidden": true,
              "desc": "The scheduler to use"
            },
            "dirsig": {
              "type": "int",
              "value": 1,
              "hidden": true,
              "desc": "How deep we should go to check directory signature"
            },
            "error_strategy": {
              "type": "choice",
              "choices": [
                "ignore",
                "retry",
                "halk"
              ],
              "choices_desc": [
                "Ignore the error and continue to run next jobs",
                "Retry the job",
                "Halt the pipeline"
              ],
              "value": "ignore",
              "desc": "What to do when a job fails",
              "hidden": true
            },
            "num_retries": {
              "type": "int",
              "value": 3,
              "hidden": true,
              "desc": "Number of retries when a job fails. "
            }
          }
        },
        "P3": {
          "desc": "# Undescribed process.\n\n",
          "value": {
            "envs": {
              "desc": "Environment variables for the process, used across jobs",
              "value": {}
            },
            "plugin_opts": {
              "desc": "The plugin options of your pipeline",
              "value": {
                "<plugin_name>_<plugin_opt_name>": {
                  "desc": "The value of plugin option `<plugin_name>_<plugin_opt_name>`",
                  "type": "str"
                }
              }
            },
            "scheduler_opts": {
              "desc": "The scheduler options",
              "value": {
                "<option_name>": {
                  "type": "auto",
                  "desc": "The value of the option"
                }
              }
            },
            "forks": {
              "type": "int",
              "value": 1,
              "desc": "Number of jobs to run in parallel for each process\n\nThe ability to run multiple jobs in parallel is provided by the the scheduler\nsystem. For example, if you use the local scheduler, the jobs will be run in\nparallel using the `multiprocessing` module. If you use the `sge` scheduler,\nthe jobs will be submitted to the slurm scheduler and run in parallel.\n"
            },
            "cache": {
              "type": "auto",
              "value": true,
              "hidden": true,
              "desc": "# Job caching\n\nIf cache set to False (detected in the sequence of configuration files,\nPipen constructor, and process definition), the job is running anyway\nregardless of previous runs.\n\nIf a previous run of a job fails, the job will be running anyway.\n\nIf a job is done successfully, a signature file will be generated for\nthe job. When we try to run the job again, the signature will be used\nto check if we can skip running the job again but to use the results\ngenerated by previous run.\n\nWe can also do a force-cache for a job by setting cache to \"force\".\nThis make sure of the results of previous successful run regardless of\ninput or script changes. This is useful for the cases that, for example,\nyou make some changes to input/script, but you don't want them to take\neffect immediately, especially when the job takes long time to run.\n"
            },
            "scheduler": {
              "value": "local",
              "hidden": true,
              "desc": "The scheduler to use"
            },
            "dirsig": {
              "type": "int",
              "value": 1,
              "hidden": true,
              "desc": "How deep we should go to check directory signature"
            },
            "error_strategy": {
              "type": "choice",
              "choices": [
                "ignore",
                "retry",
                "halk"
              ],
              "choices_desc": [
                "Ignore the error and continue to run next jobs",
                "Retry the job",
                "Halt the pipeline"
              ],
              "value": "ignore",
              "desc": "What to do when a job fails",
              "hidden": true
            },
            "num_retries": {
              "type": "int",
              "value": 3,
              "hidden": true,
              "desc": "Number of retries when a job fails. "
            }
          }
        }
      }
    }
  }
}