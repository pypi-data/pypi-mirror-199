# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/routes/datacenter.ipynb.

# %% auto 0
__all__ = ['Datacenter_Enum', 'Dataflow_Type_Filter_Enum', 'generate_search_datacenter_body',
           'generate_search_datacenter_account_body', 'search_datacenter', 'get_lineage_upstream']

# %% ../../nbs/routes/datacenter.ipynb 2
from enum import Enum

import httpx

import domolibrary.client.get_data as gd
import domolibrary.client.ResponseGetData as rgd
import domolibrary.client.DomoAuth as dmda

# %% ../../nbs/routes/datacenter.ipynb 3
class Datacenter_Enum(Enum):
    DATASET = "DATASET"
    DATAFLOW = "DATAFLOW"
    ACCOUNT = "ACCOUNT"


class Dataflow_Type_Filter_Enum(Enum):
    ADR = {
        "filterType": "term",
        "field": "data_flow_type",
        "value": "ADR",
        "name": "ADR",
        "not": False,
    }

    MYSQL = {
        "filterType": "term",
        "field": "data_flow_type",
        "value": "MYSQL",
        "name": "MYSQL",
        "not": False,
    }

    REDSHIFT = {
        "filterType": "term",
        "field": "data_flow_type",
        "value": "MYSQL",
        "name": "MYSQL",
        "not": False,
    }

    MAGICV2 = {
        "filterType": "term",
        "field": "data_flow_type",
        "value": "MAGIC",
        "name": "Magic ETL v2",
        "not": False,
    }

    MAGIC = {
        "filterType": "term",
        "field": "data_flow_type",
        "value": "ETL",
        "name": "Magic ETL",
        "not": False,
    }

# %% ../../nbs/routes/datacenter.ipynb 4
def generate_search_datacenter_body(
    entities_list: list[str] = None, # defaults to Dataset
    filters: list[dict] = None,
    combineResults: bool = True,
    count: int = 10,
    offset: int = 0,
):
    entities_list = entities_list or ["DATASET"]
    return {
        "entities": entities_list,
        "filters": filters or [],
        "combineResults": combineResults,
        "query": "*",
        "count": count,
        "offset": offset,
    }

# %% ../../nbs/routes/datacenter.ipynb 5
def generate_search_datacenter_account_body(
    search_str: str, is_exact_match: bool = True
):
    return {
        "count": 100,
        "offset": 0,
        "combineResults": False,
        "query": search_str if is_exact_match else f"*{search_str}*",
        "filters": [],
        "facetValuesToInclude": [
            "DATAPROVIDERNAME",
            "OWNED_BY_ID",
            "VALID",
            "USED",
            "LAST_MODIFIED_DATE",
        ],
        "queryProfile": "GLOBAL",
        "entityList": [["account"]],
        "sort": {"fieldSorts": [{"field": "display_name_sort", "sortOrder": "ASC"}]},
    }

# %% ../../nbs/routes/datacenter.ipynb 6
async def search_datacenter(
    auth: dmda.DomoAuth,
    loop_until_end: bool = True,
    maximum: int = None,
    body: dict = None,
    entity_ls: list[str] = None, # defaults to dataset
    arr_fn: callable = None,
    limit=100,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
) -> rgd.ResponseGetData:

    entity_ls = entity_ls or ["DATASET"]
    if not body:
        body = generate_search_datacenter_body(
            entities_list=entity_ls,
            filters=[],
            combineResults=False,
        )

    if not arr_fn:

        def arr_fn(res):
            return res.response.get("searchObjects")

    url = f"https://{auth.domo_instance}.domo.com/api/search/v1/query"

    res = await gd.looper(
        auth=auth,
        session=session,
        url=url,
        body=body,
        offset_params={"offset": "offset", "limit": "count"},
        arr_fn=arr_fn,
        method="POST",
        maximum = maximum,
        offset_params_in_body=True,
        limit=limit,
        loop_until_end=loop_until_end,
        debug_api=debug_api,
    )

    return res

# %% ../../nbs/routes/datacenter.ipynb 9
async def get_lineage_upstream(
    auth: dmda.DomoAuth,
    entity_type: str,
    entity_id: str,
    session: httpx.AsyncClient = None,
    debug_api: bool = False,
):
    url = f"https://{auth.domo_instance}.domo.com/api/data/v1/lineage/{entity_type}/{entity_id}"

    params = {"traverseDown": "false"}

    return await gd.get_data(
        auth=auth,
        method="GET",
        url=url,
        params=params,
        session=session,
        debug_api=debug_api,
    )
