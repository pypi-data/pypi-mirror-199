{"version":3,"sources":["index.tsx"],"names":["labelDiv","document","body","appendChild","createElement","label","createTextNode","container","classList","add","Streamlit","events","addEventListener","RENDER_EVENT","event","data","detail","textContent","args","options","icons","index","label_visibility","centered","multi_select","clearable","style","visibility","display","justifyContent","childNodes","length","selected","forEach","option","i","pill","icon_span","push","onclick","unselect","contains","filter","item","remove","setComponentValue","querySelectorAll","el","theme","font","color","textColor","base","setFrameHeight","setComponentReady"],"mappings":"+JAAA,kBAEMA,EAAWC,SAASC,KAAKC,YAAYF,SAASG,cAAc,UAC5DC,EAAQL,EAASG,YAAYF,SAASK,eAAe,KACrDC,EAAYN,SAASC,KAAKC,YAAYF,SAASG,cAAc,QACnEG,EAAUC,UAAUC,IAAI,aAkHxBC,IAAUC,OAAOC,iBAAiBF,IAAUG,cA3G5C,SAAkBC,GAEhB,IAAMC,EAAQD,EAAkCE,OAEhDX,EAAMY,YAAcF,EAAKG,KAAL,MACpB,IAAIC,EAAUJ,EAAKG,KAAL,QACVE,EAAQL,EAAKG,KAAL,MACRG,EAAQN,EAAKG,KAAL,MACRI,EAAmBP,EAAKG,KAAL,iBACnBK,EAAWR,EAAKG,KAAL,SACXM,EAAeT,EAAKG,KAAL,YACfO,EAAYV,EAAKG,KAAL,UAehB,GAZyB,WAArBI,IACFtB,EAAS0B,MAAMC,WAAa,UAEL,cAArBL,IACFtB,EAAS0B,MAAME,QAAU,SAGV,IAAbL,IACFhB,EAAUC,UAAUC,IAAI,YACxBT,EAAS0B,MAAMG,eAAiB,UAGE,IAAhCtB,EAAUuB,WAAWC,OAAc,CACrC,IAAIC,EAAqB,GAEzBb,EAAQc,SAAQ,SAACC,EAAgBC,GAC/B,IAAIC,EAAO7B,EAAUJ,YAAYF,SAASG,cAAc,QAGxD,GAFAgC,EAAK5B,UAAUC,IAAI,QAEfW,EAAO,CACT,IAAIiB,EAAYD,EAAKjC,YAAYF,SAASG,cAAc,SACxDiC,EAAU7B,UAAUC,IAAI,QACxB4B,EAAUpB,YAAcG,EAAMe,GAGhCC,EAAKjC,YAAYF,SAASK,eAAe4B,IAErCC,IAAMd,IACRW,EAASM,KAAKH,GACdC,EAAK5B,UAAUC,IAAI,aAGrB2B,EAAKG,QAAU,WAIb,IAAIC,EAAWf,GAAaW,EAAK5B,UAAUiC,SAAS,YAEhDjB,EACEgB,GAGFR,EAAWA,EAASU,QAAO,SAAAC,GAAI,OAAIA,IAASR,KAC5CC,EAAK5B,UAAUoC,OAAO,YACtBlC,IAAUmC,kBAAkBb,KAE5BA,EAASM,KAAKH,GACdC,EAAK5B,UAAUC,IAAI,YACnBC,IAAUmC,kBAAkBb,KAG9BzB,EAAUuC,iBAAiB,aAAab,SAAQ,SAACc,GAC/CA,EAAGvC,UAAUoC,OAAO,eAGlBJ,EAGF9B,IAAUmC,kBAAkB,SAE5BT,EAAK5B,UAAUC,IAAI,YACnBC,IAAUmC,kBAAkBV,SAQlCpB,EAAKiC,QACPhD,EAAS0B,MAAMuB,KAAOlC,EAAKiC,MAAMC,KACjCjD,EAAS0B,MAAMwB,MAAQnC,EAAKiC,MAAMG,UACV,SAApBpC,EAAKiC,MAAMI,KACbnD,SAASC,KAAK4C,iBAAiB,SAASb,SAAQ,SAACc,GAC/CA,EAAGvC,UAAUC,IAAI,WAGnBR,SAASC,KAAK4C,iBAAiB,SAASb,SAAQ,SAACc,GAC/CA,EAAGvC,UAAUoC,OAAO,YAW1BlC,IAAU2C,oBAQZ3C,IAAU4C,oBAIV5C,IAAU2C,mB","file":"static/js/main.ff7c57c2.chunk.js","sourcesContent":["import { Streamlit, RenderData } from \"streamlit-component-lib\"\r\n\r\nconst labelDiv = document.body.appendChild(document.createElement(\"label\"))\r\nconst label = labelDiv.appendChild(document.createTextNode(\"\"))\r\nconst container = document.body.appendChild(document.createElement(\"div\"))\r\ncontainer.classList.add(\"container\")\r\n\r\n/**\r\n * The component's render function. This will be called immediately after\r\n * the component is initially loaded, and then again every time the\r\n * component gets new data from Python.\r\n */\r\nfunction onRender(event: Event): void {\r\n  // Get the RenderData from the event\r\n  const data = (event as CustomEvent<RenderData>).detail\r\n\r\n  label.textContent = data.args[\"label\"]\r\n  let options = data.args[\"options\"]\r\n  let icons = data.args[\"icons\"]\r\n  let index = data.args[\"index\"]\r\n  let label_visibility = data.args[\"label_visibility\"]\r\n  let centered = data.args[\"centered\"]\r\n  let multi_select = data.args[\"multiselect\"]\r\n  let clearable = data.args[\"clearable\"]\r\n  // console.log(captions)\r\n\r\n  if (label_visibility === \"hidden\") {\r\n    labelDiv.style.visibility = \"hidden\"\r\n  }\r\n  if (label_visibility === \"collapsed\") {\r\n    labelDiv.style.display = \"none\"\r\n  }\r\n\r\n  if (centered === true) {\r\n    container.classList.add(\"centered\")\r\n    labelDiv.style.justifyContent = \"center\";\r\n  }\r\n\r\n  if (container.childNodes.length === 0) {\r\n    var selected: number[] = [];\r\n\r\n    options.forEach((option: string, i: number) => {\r\n      let pill = container.appendChild(document.createElement(\"div\"))\r\n      pill.classList.add(\"pill\")\r\n\r\n      if (icons) {\r\n        let icon_span = pill.appendChild(document.createElement(\"span\"))\r\n        icon_span.classList.add(\"icon\")\r\n        icon_span.textContent = icons[i]\r\n      }\r\n\r\n      pill.appendChild(document.createTextNode(option))\r\n\r\n      if (i === index) {\r\n        selected.push(i)\r\n        pill.classList.add(\"selected\")\r\n      }\r\n\r\n      pill.onclick = function () {\r\n        // If the element is clearable, let the user unselect by clicking on the pill\r\n        // again. I.e. if this pill (which is clicked) was already selected before, we\r\n        // unselect it later.\r\n        let unselect = clearable && pill.classList.contains(\"selected\")\r\n\r\n        if (multi_select) {\r\n          if (unselect) {\r\n            // Need to pass a string here and convert it to None on the Python side.\r\n            // If setting null, the components lib returns the \"default\" value (=index).\r\n            selected = selected.filter(item => item !== i)\r\n            pill.classList.remove(\"selected\")\r\n            Streamlit.setComponentValue(selected)\r\n          } else {\r\n            selected.push(i)\r\n            pill.classList.add(\"selected\")\r\n            Streamlit.setComponentValue(selected)\r\n          }\r\n        } else {\r\n          container.querySelectorAll(\".selected\").forEach((el) => {\r\n            el.classList.remove(\"selected\")\r\n          })\r\n\r\n          if (unselect) {\r\n            // Need to pass a string here and convert it to None on the Python side.\r\n            // If setting null, the components lib returns the \"default\" value (=index).\r\n            Streamlit.setComponentValue('None')\r\n          } else {\r\n            pill.classList.add(\"selected\")\r\n            Streamlit.setComponentValue(i)\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  // Style according to the app theme.\r\n  if (data.theme) {\r\n    labelDiv.style.font = data.theme.font\r\n    labelDiv.style.color = data.theme.textColor\r\n    if (data.theme.base === \"dark\") {\r\n      document.body.querySelectorAll(\".pill\").forEach((el) => {\r\n        el.classList.add(\"dark\")\r\n      })\r\n    } else {\r\n      document.body.querySelectorAll(\".pill\").forEach((el) => {\r\n        el.classList.remove(\"dark\")\r\n      })\r\n    }\r\n\r\n    // TODO: Gray out the component and disable click if it's disabled.\r\n  }\r\n\r\n  // We tell Streamlit to update our frameHeight after each render event, in\r\n  // case it has changed. (This isn't strictly necessary for the example\r\n  // because our height stays fixed, but this is a low-cost function, so\r\n  // there's no harm in doing it redundantly.)\r\n  Streamlit.setFrameHeight()\r\n}\r\n\r\n// Attach our `onRender` handler to Streamlit's render event.\r\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\r\n\r\n// Tell Streamlit we're ready to start receiving data. We won't get our\r\n// first RENDER_EVENT until we call this function.\r\nStreamlit.setComponentReady()\r\n\r\n// Finally, tell Streamlit to update our initial height. We omit the\r\n// `height` parameter here to have it default to our scrollHeight.\r\nStreamlit.setFrameHeight()\r\n"],"sourceRoot":""}