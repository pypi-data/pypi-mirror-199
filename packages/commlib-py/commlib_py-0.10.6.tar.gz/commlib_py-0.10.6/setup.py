# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['commlib', 'commlib.transports']

package_data = \
{'': ['*']}

install_requires = \
['hiredis==2.1.1',
 'paho-mqtt==1.6.1',
 'pika==1.3.1',
 'pydantic==1.10.4',
 'ujson==5.7.0']

setup_kwargs = {
    'name': 'commlib-py',
    'version': '0.10.6',
    'description': 'Internal  DSL for communication and messaging in CPS',
    'long_description': '# commlib-py\nBroker-based communication framework written in python 3.\nImplements the most common communication patterns (RPC/ReqResp, PubSub) over a message broker.\nA message broker is a communication middleware responsible for routing messages to the\nproper endpoints. Some examples of message brokers are: AMQP brokers (e.g. RabbitMQ),\nApache Kafka, MQTT brokers (e.g. Mosquito and EMQX) and Redis.\n\nYes, Redis can also be used as a message broker for RPC and PubSub communication!!\n\nCurrently, AMQP, Redis and MQTT brokers are supported.\n\nThe goal of this project is to implement a standard communication middleware\nbased on message brokers, for building systems. A system can be a device, \nan IoT environment or a software platformm. Performance is also considered\nas it is often used on low-cost devices, so messaging has to be fast and with\nlow footprint.\n\n\n# Installation\n\n\n```bash\npython setup.py install\n```\n\n, or via pip\n\n```bash\npip install .\n```\n\n, or by giving the git repo url to pip\n\n```bash\npip install git+https://github.com/robotics-4-all/commlib-py.git@master\n```\n\nIn order to keep minimal footprint of the implementation, the backend\ncommunication transports (AMQP, MQTT, Redis etc) are not installed by default.\n\n## Redis Support\n\nIn order to have access to the Redis transport you will have to install the\n`redis` python package\n\n```bash\npip install redis\n```\n\nHowever, there’s also a C library, Hiredis, that contains a fast parser that can offer significant speedups for some Redis commands such as LRANGE. You can think of Hiredis as an optional accelerator for Redis commands.\n\nIt is highly recommended to also install hiredis.\n\n```\npip install hiredis\n```\n\n## AMQP Support\n\nIn order to have access to the AMQP transport you will have to installed the following dependencies:\n\n- pika==1.1.0\n\n```bash\npip install "pika==1.1.0"\n```\n\n\n## MQTT Support\n\nIn order to have access to the MQTT transport you will have to installed the following dependencies:\n\n- paho-mqtt\n\n```bash\npip install paho-mqtt\n```\n\n\n## JSON Serialization\n\nIt is recommended to use a fast json library, such as [orjson](https://github.com/ijl/orjson) \nor [ujson](https://github.com/ultrajson/ultrajson).\n\nThe framework will load and use the most performance optimal library based\non installations.\n\n\n# Quick Start\n\nThe purpose of this implementation is to provide an application-level communication layer, \nby providing implementations for Remote-Procedure-Calls (RPCs), Topic-based PubSub, Preemptable Services (aka Actions), Events etc.\n\n\n# User Guide\n\n## Node\n\nA **Node** is a software component that follows the Component-Port-Connector model.\nIt has input and output ports for communicating with the world. Each\nport defines an endpoint and can be of the following types.\n\n```\n         +-----------------+\n         |                 |\nInPort  +-+     Node      +-+ OutPort\n        +-+               +-+\n         |                 |\n         +-----------------+\n```\n\n```\n                        +--------+                         \n+----------+ OutPort    |        |      InPort +----------+\n|         +-+ --------> |        | ---------> +-+         |\n|         +-+           |        |            +-+         |\n| Node A   |            | Broker |             |   Node B |\n|         +-+ <-------- |        | <--------- +-+         |\n|         +-+           |        |            +-+         |\n+----------+ InPort     |        |     OutPort +----------+\n                        +--------+\n```\n\n**Input Port**:\n  - Subscriber\n  - RPC Service\n  - Action Service\n\n**Output Port**:\n  - Publisher\n  - RPC Client\n  - Action Client\n  - Event Emitter\n\n**InOut Port**:\n  - RPCBridge: Bridge RPC Communication between two brokers. Directional.\n  - TopicBridge: Bridge PubSub Communication between two brokers. Directional.\n  - PTopicBridge: Bridge PubSub Communication between two brokers, based on a topic pattern. Directional.\n\n\nFurthermore, it implements several features:\n- Publish Heartbeat messages in the background for as long as the node is active\n- Provide control interfaces, to `start` and `stop` the execution of the Node\n- Provides methods to create endpoints and bind to Node ports.\n\n```python\nfrom commlib.node import Node, TransportType\nfrom commlib.msg import RPCMessage\n## Import the Redis transports\n## Imports are lazy handled internally\nfrom commlib.transports.redis import ConnectionParameters\n\nclass AddTwoIntMessage(RPCMessage):\n    class Request(RPCMessage.Request):\n        a: int = 0\n        b: int = 0\n\n    class Response(RPCMessage.Response):\n        c: int = 0\n\n\ndef on_request(msg):\n    print(f\'On-Request: {msg}\')\n    resp = AddTwoIntMessage.Response(c = msg.a + msg.b)\n    return resp\n\n\nif __name__ == \'__main__\':\n    conn_params = ConnectionParameters()\n    node = Node(node_name=\'add_two_ints_node\',\n                connection_params=conn_params,\n                # heartbeat_uri=\'nodes.add_two_ints.heartbeat\',\n                debug=True)\n    rpc = node.create_rpc(msg_type=AddTwoIntMessage,\n                          # rpc_name=\'add_two_ints_node.add_two_ints\',\n                          on_request=add_two_int_handler)\n    node.run_forever(sleep_rate=1)\n```\n\nA Node always binds to a specific broker for implementing the input and\noutput ports. Of course you can instantiate and run several Nodes in a single-process \napplication.\n\n### Node class:\n\n```python\nclass Node:\n    def __init__(self,\n                 node_name: Optional[str] = \'\',\n                 connection_params: Optional[Any] = None,\n                 transport_connection_params: Optional[Any] = None,\n                 debug: Optional[bool] = False,\n                 heartbeats: Optional[bool] = True,\n                 heartbeat_uri: Optional[str] = None,\n                 compression: CompressionType = CompressionType.NO_COMPRESSION,\n                 ctrl_services: Optional[bool] = False):\n```\n\nNode methods to create and run Endpoints::\n\n```\n▾+Node : class\n   +create_action(self, *args, **kwargs) : member\n   +create_action_client(self, *args, **kwargs) : member\n   +create_event_emitter(self, *args, **kwargs) : member\n   +create_heartbeat_thread(self) : member\n   +create_mpublisher(self, *args, **kwargs) : member\n   +create_psubscriber(self, *args, **kwargs) : member\n   +create_publisher(self, *args, **kwargs) : member\n   +create_rpc(self, *args, **kwargs) : member\n   +create_rpc_client(self, *args, **kwargs) : member\n   +create_start_service(self, uri: str = None) : member\n   +create_stop_service(self, uri: str = None) : member\n   +create_subscriber(self, *args, **kwargs) : member\n   +run(self) : member\n   +run_forever(self, sleep_rate: float = 0.001) : member\n   +stop(self) : member\n```\n\n## Endpoint (Low-level API)\n\nIt is possible to construct endpoints without binding them to a specific\nNode. This is a feature to support a wider range of applications, where the\nconcept Node might not be usable.\n\nOne can create endpoint instances by using the following classes of each\nsupported transport\n\n- RPCClient\n- RPCServer\n- Publisher\n- Subscriber\n- MPublisher (Multi-topic Publisher)\n- PSubscriber (Pattern-based Subscriber)\n- ActionService (Preemptable Services with feedback)\n- ActionClient\n- EventEmitter\n\n\n```python\nfrom commlib.transports.redis import RPCService\nfrom commlib.transports.amqp import Subscriber\nfrom commlib.transports.mqtt import Publisher, RPCClient\n...\n```\n\nOr use the `endpoint_factory` to construct endpoints.\n\n```python\nimport time\nfrom commlib.endpoints import endpoint_factory, EndpointType, TransportType\n\n\ndef callback(data):\n    print(data)\n\n\nif __name__ == \'__main__\':\n    topic = \'factory_test_topic\'\n    mqtt_sub = endpoint_factory(EndpointType.Subscriber, TransportType.MQTT)(\n        topic=topic,\n        on_message=callback\n    )\n    mqtt_sub.run()\n    mqtt_pub = endpoint_factory(EndpointType.Publisher, TransportType.MQTT)(\n        topic=topic,\n        debug=True\n    )\n\n    data = {\'a\': 1, \'b\': 2}\n    while True:\n        mqtt_pub.publish(data)\n        time.sleep(1)\n```\n\n## Req/Resp (RPC) Communication\n\n```\n                             +---------------+\n                   +-------->+   RPC Topic   +------+\n+--------------+   |         |               |      |        +---------------+\n|              +---+         +---------------+      +------->+               |\n|  RPC Client  |                                             |  RPC Service  |\n|              +<--+         +---------------+      +--------+               |\n+--------------+   |         |Temporaty Topic|      |        +---------------+\n                   +---------+               +<-----+\n                             +---------------+\n```\n\n\n### Server Side Example\n\n```python\nfrom commlib.msg import RPCMessage\nfrom commlib.node import Node\nfrom commlib.transports.mqtt import ConnectionParameters\n\n\nclass AddTwoIntMessage(RPCMessage):\n    class Request(RPCMessage.Request):\n        a: int = 0\n        b: int = 0\n\n    class Response(RPCMessage.Response):\n        c: int = 0\n\n\ndef add_two_int_handler(msg):\n    print(f\'Request Message: {msg.__dict__}\')\n    resp = AddTwoIntMessage.Response(c = msg.a + msg.b)\n    return resp\n\n\nif __name__ == \'__main__\':\n    conn_params = ConnectionParameters()\n    node = Node(node_name=\'add_two_ints_node\',\n                connection_params=conn_params,\n                # heartbeat_uri=\'nodes.add_two_ints.heartbeat\',\n                debug=True)\n    rpc = node.create_rpc(msg_type=AddTwoIntMessage,\n                          rpc_name=\'add_two_ints_node.add_two_ints\',\n                          on_request=add_two_int_handler)\n    node.run_forever(sleep_rate=1)\n```\n\n### Client Side Example\n\n```python\nimport time\n\nfrom commlib.msg import RPCMessage\nfrom commlib.node import Node\nfrom commlib.transports.mqtt import ConnectionParameters\n\n\nclass AddTwoIntMessage(RPCMessage):\n    class Request(RPCMessage.Request):\n        a: int = 0\n        b: int = 0\n\n    class Response(RPCMessage.Response):\n        c: int = 0\n\n\nif __name__ == \'__main__\':\n    conn_params = ConnectionParameters()\n    node = Node(node_name=\'myclient\',\n                connection_params=conn_params,\n                # heartbeat_uri=\'nodes.add_two_ints.heartbeat\',\n                debug=True)\n    rpc = node.create_rpc_client(msg_type=AddTwoIntMessage,\n                                 rpc_name=\'add_two_ints_node.add_two_ints\')\n    node.run()\n\n    # Create an instance of the request object\n    msg = AddTwoIntMessage.Request()\n    while True:\n        # returns AddTwoIntMessage.Response instance\n        resp = rpc.call(msg)\n        print(resp)\n        msg.a += 1\n        msg.b += 1\n        time.sleep(1)\n```\n\n\n## PubSub Communicaton\n\n```\n                                                    +------------+\n                                                    |            |\n                                            +------>+ Subscriber |\n                                            |       |            |\n                                            |       +------------+\n                                            |\n+-----------+             +------------+    |       +------------+\n|           |             |            |    |       |            |\n| Publisher +------------>+   Topic    +----------->+ Subscriber |\n|           |             |            |    |       |            |\n+-----------+             +------------+    |       +------------+\n                                            |\n                                            |       +------------+\n                                            |       |            |\n                                            +------>+ Subscriber |\n                                                    |            |\n                                                    +------------+\n```\n\n### Write a Simple Topic Publisher\n\n```python\nimport time\n\nfrom commlib.msg import PubSubMessage\nfrom commlib.transports.mqtt import Publisher, ConnectionParameters\n\n\nclass SonarMessage(PubSubMessage):\n    distance: float = 0.001\n    horizontal_fov: float = 30.0\n    vertical_fov: float = 14.0\n\n\nif __name__ == "__main__":\n    conn_params = ConnectionParameters(host=\'localhost\', port=1883)\n    pub = Publisher(topic=topic, msg_type=SonarMessage, conn_params=conn_params)\n    pub.run()\n    msg = SonarMessage(distance=2.0)\n    while True:\n        time.sleep(0.5)\n        pub.publish(msg)\n        msg.distance += 1\n\n```\n\n### Write a Simple Topic Subscriber\n\n```python\nimport time\n\nfrom commlib.msg import PubSubMessage, DataClass\nfrom commlib.transports.mqtt import (\n    Subscriber, ConnectionParameters\n)\n\n\n@DataClass\nclass SonarMessage(PubSubMessage):\n    distance: float = 0.001\n    horizontal_fov: float = 30.0\n    vertical_fov: float = 14.0\n\n\ndef sonar_data_callback(msg):\n    print(f\'Message: {msg}\')\n\n\nif __name__ == "__main__":\n    conn_params = ConnectionParameters(host=\'localhost\', port=1883)\n    sub = Subscriber(topic=topic,\n                     on_message=sonar_data_callback,\n                     conn_params=conn_params)\n    sub.run()\n    while True:\n        time.sleep(0.001)\n```\n\n## Pattern-based Topic Subscription\n\nFor pattern-based topic subscription use the `PSubscriber` class.\n\n```python\n#!/usr/bin/env python\n\nimport sys\nimport time\n\nfrom commlib.msg import PubSubMessage\n\n\nclass SonarMessage(PubSubMessage):\n    distance: float = 0.001\n    horizontal_fov: float = 30.0\n    vertical_fov: float = 14.0\n\n\ndef sensor_data_callback(msg, topic):\n    print(f\'Sensor Data Message: {topic}:{msg}\')\n\n\nif __name__ == \'__main__\':\n    topic = \'sensors.*\'\n    p1_topic = topic.split(\'*\')[0] + \'sonar.front\'\n    p2_topic = topic.split(\'*\')[0] + \'ir.rear\'\n\n    # Create an instance of a Patter-based Subscriber (PSubscriber)\n    sub = PSubscriber(topic=topic, msg_type=SonarMessage,\n                      on_message=sensor_data_callback)\n    # Run the PSubscriber in the background.\n    sub.run()\n\n    # Create an instance of the communication message\n    msg = SonarMessage()\n\n    # Create an instalce of a Multi-topic Publisher (MPublisher)\n    pub = MPublisher(msg_type=SonarMessage)\n    pub.run()\n\n    while True:\n        time.sleep(1)\n        # Publish message to topic A\n        pub.publish(msg, p1_topic)\n        # Publish message to topic B\n        pub.publish(msg, p2_topic)\n        msg.distance += 1\n```\n\n## Preemptable Services with Feedback (Actions)\n\nActions are [pre-emptable services](https://en.wikipedia.org/wiki/Preemption_(computing)) \nwith support for asynchronous feedback publishing. This communication pattern\nis used to implement services which can be stopped and can provide feedback data, such \nas the move command service of a robot.\n\n\n### Write an Action Service\n\n```python\nimport time\n\nfrom commlib.action import GoalStatus\nfrom commlib.msg import ActionMessage\nfrom commlib.transports.redis import ActionService, ConnectionParameters\n)\n\n\nclass ExampleAction(ActionMessage):\n    class Goal(ActionMessage.Goal):\n        target_cm: int = 0\n\n    class Result(ActionMessage.Result):\n        dest_cm: int = 0\n\n    class Feedback(ActionMessage.Feedback):\n        current_cm: int = 0\n\n\ndef on_goal(goal_h):\n    c = 0\n    res = ExampleAction.Result()\n    while c < goal_h.data.target_cm:\n        if goal_h.cancel_event.is_set():\n            break\n        goal_h.send_feedback(ExampleAction.Feedback(current_cm=c))\n        c += 1\n        time.sleep(1)\n    res.dest_cm = c\n    return res\n\n\nif __name__ == \'__main__\':\n    action_name = \'testaction\'\n    conn_params = ConnectionParameters()\n    action = ActionService(msg_type=ExampleAction,\n                           conn_params=conn_params,\n                           action_name=action_name,\n                           on_goal=on_goal)\n    action.run()\n    while True:\n      time.sleep(0.001)\n```\n\n### Write an Action Client\n\n```python\nimport time\n\nfrom commlib.action import GoalStatus\nfrom commlib.msg import ActionMessage\nfrom commlib.transports.redis import ActionClient, ConnectionParameters\n\n\nclass ExampleAction(ActionMessage):\n    class Goal(ActionMessage.Goal):\n        target_cm: int = 0\n\n    class Result(ActionMessage.Result):\n        dest_cm: int = 0\n\n    class Feedback(ActionMessage.Feedback):\n        current_cm: int = 0\n\n\ndef on_feedback(feedback):\n    print(f\'ActionClient <on-feedback> callback: {feedback}\')\n\n\ndef on_goal_reached(result):\n    print(f\'ActionClient <on-goal-reached> callback: {result}\')\n\n\nif __name__ == \'__main__\':\n    action_name = \'testaction\'\n    conn_params = ConnectionParameters()\n    action_c = ActionClient(msg_type=ExampleAction,\n                            conn_params=conn_params,\n                            action_name=action_name,\n                            on_feedback=on_feedback,\n                            on_goal_reached=on_goal_reached)\n    action_c.run()\n    goal_msg = ExampleAction.Goal(target_cm=5)\n    action_c.send_goal(goal_msg)\n    resp = action_c.get_result(wait=True)\n    print(resp)\n```\n\n## EventEmitter\n\nAn EventEmitter can be used to fire multiple events, for event-based systems, over a single connection.\n\n```\n                                +---------+\n        +---------------------> | Topic A |\n        |                       +---------+\n        |                                  \n        |                                  \n+---------------+                          \n|               |               +---------+\n|  EventEmitter |-------------->| Topic B |\n|               |               +---------+\n+---------------+                          \n        |                                  \n        |                                  \n        |                       +---------+\n        +---------------------> | Topic C |\n                                +---------+\n```\n\nAn Event has the following properties:\n\n```python\nclass Event(BaseModel):\n    name: Text\n    uri: Text\n    description: Text = \'\'\n    data: Dict[str, Any] = {}\n```\n\n- name: The name of the Event\n- uri: Broker URI to send the Event\n- description: Optional Description of the Event.\n- data: Optional data to attach on the Event.\n\nBelow is an example of an EventEmitter used to fire the `bedroom.lights.on` and `bedroom.lights.off` events.\n\n```python\n#!/usr/bin/env python\n\nimport time\n\nfrom commlib.events import Event\nfrom commlib.transports.mqtt import EventEmitter, ConnectionParameters\n\n\nif __name__ == \'__main__\':\n    conn_params = ConnectionParameters()\n    emitter = EventEmitter(conn_params=conn_params, debug=True)\n\n    eventA = Event(name=\'TurnOnBedroomLights\', uri=\'bedroom.lights.on\')\n    eventB = Event(name=\'TurnOffBedroomLights\', uri=\'bedroom.lights.off\')\n\n    emitter.send_event(eventA)\n    time.sleep(2)\n    emitter.send_event(eventB)\n```\n\n\n## Broker-to-broker (B2B) bridges\n\nIn the context of IoT and CPS, it is a common requirement to bridge messages\nbetween message brokers, based on application-specific rules. An example is to \nbridge analytics (preprocessed) data from the Edge to the Cloud. And what happens\nif the brokers use different communication protocols?\n\n\n```\n                                  {Bridge}\n[Producer] -------> [Broker A] -------------> [Broker B] ------> [Consumer]\n                                  {Bridge}\n```\n\nIn the context of the current work, communication bridges are implemented for\nPubSub and RPC communication between various message brokers. Currently, MQTT, \nAMQP and Redis are supported.\n\n![bridges_1](./assets/BrokerMessaging-Bridges.png)\n\n\nBelow are examples of an MQTT Redis-to-MQTT Bridge and a Redis-to-MQTT\nTopic Bridge.\n\n```python\n#!/usr/bin/env python\n\nimport time\n\nimport commlib.transports.amqp as acomm\nimport commlib.transports.redis as rcomm\nimport commlib.transports.mqtt as mcomm\n\nfrom commlib.bridges import (\n    RPCBridge, RPCBridgeType, TopicBridge, TopicBridgeType\n)\n\n\ndef redis_to_mqtt_rpc_bridge():\n    """\n    [RPC Client] ----> [Broker A] ------> [Broker B] ---> [RPC Service]\n    """\n    bA_params = rcomm.ConnectionParameters()\n    bB_params = mcomm.ConnectionParameters()\n    bA_uri = \'ops.start_navigation\'\n    bB_uri = \'thing.robotA.ops.start_navigation\'\n    br = RPCBridge(RPCBridgeType.REDIS_TO_MQTT,\n                   from_uri=bA_uri, to_uri=bB_uri,\n                   from_broker_params=bA_params,\n                   to_broker_params=bB_params,\n                   debug=False)\n    br.run()\n\n\ndef redis_to_mqtt_topic_bridge():\n    """\n    [Producer Endpoint] ---> [Broker A] ---> [Broker B] ---> [Consumer Endpoint]\n    """\n    bA_params = rcomm.ConnectionParameters()\n    bB_params = mcomm.ConnectionParameters()\n    bA_uri = \'sonar.front\'\n    bB_uri = \'thing.robotA.sensors.sonar.font\'\n    br = TopicBridge(TopicBridgeType.REDIS_TO_MQTT,\n                     from_uri=bA_uri, to_uri=bB_uri,\n                     from_broker_params=bA_params,\n                     to_broker_params=bB_params,\n                     debug=False)\n    br.run()\n\n\nif __name__ == \'__main__\':\n    redis_to_mqtt_rpc_bridge()\n    redis_to_mqtt_topic_bridge()\n```\n\nA Pattern-based Topic Bridge (PTopicBridge) example is also shown below.\n\n```python\n#!/usr/bin/env python\n\nimport time\n\nimport commlib.transports.amqp as acomm\nimport commlib.transports.redis as rcomm\nfrom commlib.msg import PubSubMessage, DataClass\n\nfrom commlib.bridges import PTopicBridge\n\n\n@DataClass\nclass SonarMessage(PubSubMessage):\n    distance: float = 0.001\n    horizontal_fov: float = 30.0\n    vertical_fov: float = 14.0\n\n\nif __name__ == \'__main__\':\n    """\n    [Broker A] ------------> [Broker B] ---> [Consumer Endpoint]\n    """\n    bA_uri = \'sensors.*\'\n    bB_namespace = \'myrobot\'\n\n    bA_params = rcomm.ConnectionParameters()\n    bB_params = mcomm.ConnectionParameters()\n\n    br = PTopicBridge(TopicBridgeType.REDIS_TO_MQTT,\n                      bA_uri,\n                      bB_namespace,\n                      bA_params,\n                      bB_params,\n                      msg_type=SonarMessage,\n                      debug=True)\n    br.run()\n```\n\n## Action bridges\n\n### TODO\n\n## TCP Bridge\n\nTCP bridge forwards tcp packages between two endpoints:\n\n```\n\n[Client] -------> [TCPBridge, port=xxxx] ---------> [TCP endpoint, port=xxxx]\n\n```\n\nA one-to-one connection is performed between the bridge and the endpoint. \n\n\n## REST Proxy\n\nImplements a REST proxy, that enables invocation of REST services via\nbroker communication. The proxy uses an RPCService to run the broker endpoint and\nan http client for calling REST services. An RPC call is transformed into proper,\nREST-compliant, http request, based on the input parameters.\n\n\n```python\nclass RESTProxyMessage(RPCMessage):\n    @DataClass\n    class Request(RPCMessage.Request):\n        host: str\n        port: int = 80\n        path: str = \'/\'\n        verb: str = \'GET\'\n        query_params: Dict = DataField(default_factory=dict)\n        path_params: Dict = DataField(default_factory=dict)\n        body_params: Dict = DataField(default_factory=dict)\n        headers: Dict = DataField(default_factory=dict)\n\n    @DataClass\n    class Response(RPCMessage.Response):\n        data: Dict = DataField(default_factory=dict)\n```\n\nResponses from the REST services are returned to clients in the form of a \n`RPCMessage.Response` message.\n\n\n## Transports\n\n### AMQP / RabbitMQ\n\nRPC (request/reply) and PubSub Endpoints are supported by the protocol itself (AMQP), using dedicated exchanges.\n\nFor RPC enpoints a `Direct Exchange` is used to route requests and responses,\noptionally using the [Direct Reply-to](https://www.rabbitmq.com/direct-reply-to.html).\nIf the `Direct Reply-to` feature is used, then RPC endpoints must publish\nto the default exchange `""`.\n\nTo use `Direct Reply-to`, an RPC client should:\n- Consume from the pseudo-queue `amq.rabbitmq.reply-to` in no-ack mode.\n- Set the `reply-to` property in their request message to `amq.rabbitmq.reply-to`.\n\nMeta-information such as the serialization method used, is passed through the\n[message properties](https://www.rabbitmq.com/consumers.html#message-properties)\nmetadata, as specified my AMQP.\n\n\n### Redis\n\nPubSub endpoints uses the out-of-the-box [Redis pubsub channel](https://redis.io/topics/pubsub) to exchange messages. PubSub message payload in Redis includes the\ndata of the message and meta-information (header) regarding serialization method used, \ntimestamp, etc. Below is an example of the payload for pubsub communication.\n\n```\n{\n  \'data\': {},\n  \'header\': {\n    \'timestamp\': <int>,\n    \'properties\': {\n      \'content_type\': \'application/json\',\n      \'content_encoding\': \'utf8\'\n    }\n  }\n}\n```\n\nThis is useful for transparency between brokers. Default values are evident\nin the previous example.\n\nReq/Resp communication (RPC) is not supported out-of-the-box. To support\nRPC communication over Redis, a custom layer implements the pattern for both endpoints \nusing Redis Lists to represent queues. RPC server listens for requests from\na list (LPOP / BLPOP), while an RPC client sends request messages to that list (RPUSH).\nIn order for the client to be able to receive responses, he must listen to a temporary queue.\nTo achieve this, the request message must include a `reply_to` property that is \nused by the RPCServer implementation to send the response message. Furthermore,\n`serialization` and `encoding` properties are defined. Finally, the header\nincludes a `timestamp`, that indicates the time that the message was sent to to wire.\n\n\nBelow is the  data model of the request message.\n\n```\n{\n  \'data\': {},\n  \'header\': {\n    \'timestamp\': <int>,\n    \'reply_to\': <str>,\n    \'properties\': {\n      \'content_type\': \'application/json\',\n      \'content_encoding\': \'utf8\'\n    }\n  }\n}\n```\n\n**Note**: The **RPC Client** implementation is responsible to remove any created \ntemporary queues!\n\n\n### MQTT\n\nPubSub message payload in MQTT includes the\ndata of the message and meta-information (header) regarding serialization method used, \ntimestamp, etc. Below is an example of the payload for pubsub communication.\n\n```\n{\n  \'data\': {},\n  \'header\': {\n    \'timestamp\': <int>,\n    \'properties\': {\n      \'content_type\': \'application/json\',\n      \'content_encoding\': \'utf8\'\n    }\n  }\n}\n```\n\nThis is useful for transparency between brokers. Default values are evident\nin the previous example.\n\nThough, Req/Resp communication (RPC) is not supported out-of-the-box. To support\nRPC communication over MQTT, a custom layer implements the pattern for both endpoints \nusing MQTT topics. RPC server listens for requests at a specific topic,\nwhile an RPC client listens to a temporary topic for response messages.\nFor the server to know where to send the response, the request message must include a `reply_to` property that is \nused by the RPCServer implementation to send the response message. Furthermore,\n`serialization` and `encoding` properties are defined. Finally, the header\nincludes a `timestamp`, that indicates the time that the message was sent to to wire.\n\nBelow is the data model of the Request message.\n\n```json\n{\n  \'data\': {},\n  \'header\': {\n    \'timestamp\': <int>,\n    \'reply_to\': <str>,\n    \'properties\': {\n      \'content_type\': \'application/json\',\n      \'content_encoding\': \'utf8\'\n    }\n  }\n}\n```\n\n# Examples\n\nExamples can be found at the [examples/](./examples) directory of this repository.\n\n\n# Tests\n\nRun tests by executing `tox` command under this repo directory:\n\n```bash\nmake tests\n```\n\n**TODO - Currently working on!!**\n\n# Docs\n\nMake docs by running:\n\n```bash\nmake docs\n```\n\n**TODO - Currently working on!!**\n\n# Contributions\n\n- [klpanagi](https://github.com/klpanagi)\n\n',
    'author': 'Konstantinos Panayiotou',
    'author_email': 'klpanagi@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
